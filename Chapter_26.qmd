---
title: "Chapter 26, Iteration"
format: gfm
---

---
title: "Chapter 26, Iteration"
format: gfm
---

```{r}
library(tidyverse)
```

# Modifying Multiple Columns

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
```

```{r}
df |> summarize(
  n = n(),
  a = median(a),
  b = median(b),
  c = median(c),
  d = median(d),
)
```
```{r}
df |> summarize(
  n = n(),
  across(a:d, median),
)
```
across():
.cols: specifies which columns you want to iterate over
.fns: specifies what to do with each column
.names: controls names of output columns

# Selecting Columns with .cols

across(everything()): selects every (non-grouping) column

where() allows you to select columns based on their type:
where(is.numeric) selects all numeric columns.
where(is.character) selects all string columns.
where(is.Date) selects all date columns.
where(is.POSIXct) selects all date-time columns.
where(is.logical) selects all logical columns.
```{r}
df <- tibble(
  grp = sample(2, 10, replace = TRUE),
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df |> 
  group_by(grp) |> 
  summarize(across(everything(), median))
```

# Calling a Single Function

```{r}
df |> 
  group_by(grp) |> 
  summarize(across(everything(), median))
```

# Calling Multiple Functions
```{r}
rnorm_na <- function(n, n_na, mean = 0, sd = 1) {
  sample(c(rnorm(n - n_na, mean = mean, sd = sd), rep(NA, n_na)))
}

df_miss <- tibble(
  a = rnorm_na(5, 1),
  b = rnorm_na(5, 1),
  c = rnorm_na(5, 2),
  d = rnorm(5)
)
df_miss |> 
  summarize(
    across(a:d, median),
    n = n()
  )
```
```{r}
df_miss |> 
  summarize(
    across(a:d, function(x) median(x, na.rm = TRUE)),
    n = n()
  )
```

```{r}
df_miss |> 
  summarize(
    across(a:d, \(x) median(x, na.rm = TRUE)),
    n = n()
  )
```
```{r}
df_miss |> 
  summarize(
    a = median(a, na.rm = TRUE),
    b = median(b, na.rm = TRUE),
    c = median(c, na.rm = TRUE),
    d = median(d, na.rm = TRUE),
    n = n()
  )
```
```{r}
df_miss |> 
  summarize(
    across(a:d, list(
      median = \(x) median(x, na.rm = TRUE),
      n_miss = \(x) sum(is.na(x))
    )),
    n = n()
  )
```

# Column Names
```{r}
df_miss |> 
  summarize(
    across(
      a:d,
      list(
        median = \(x) median(x, na.rm = TRUE),
        n_miss = \(x) sum(is.na(x))
      ),
      .names = "{.fn}_{.col}"
    ),
    n = n(),
  )
```

```{r}
df_miss |> 
  mutate(
    across(a:d, \(x) coalesce(x, 0))
  )
```

```{r}
df_miss |> 
  mutate(
    across(a:d, \(x) coalesce(x, 0), .names = "{.col}_na_zero")
  )
```
# Filtering

```{r}
# same as df_miss |> filter(is.na(a) | is.na(b) | is.na(c) | is.na(d))
df_miss |> filter(if_any(a:d, is.na))

# same as df_miss |> filter(is.na(a) & is.na(b) & is.na(c) & is.na(d))
df_miss |> filter(if_all(a:d, is.na))
```

# across() in Functions
```{r}
expand_dates <- function(df) {
  df |> 
    mutate(
      across(where(is.Date), list(year = year, month = month, day = mday))
    )
}

df_date <- tibble(
  name = c("Amy", "Bob"),
  date = ymd(c("2009-08-03", "2010-01-16"))
)

df_date |> 
  expand_dates()
```
```{r}
summarize_means <- function(df, summary_vars = where(is.numeric)) {
  df |> 
    summarize(
      across({{ summary_vars }}, \(x) mean(x, na.rm = TRUE)),
      n = n(),
      .groups = "drop"
    )
}
diamonds |> 
  group_by(cut) |> 
  summarize_means()

diamonds |> 
  group_by(cut) |> 
  summarize_means(c(carat, x:z))
```
# Compare with pivot_longer()

```{r}
df |> 
  summarize(across(a:d, list(median = median, mean = mean)))
```
```{r}
long <- df |> 
  pivot_longer(a:d) |> 
  group_by(name) |> 
  summarize(
    median = median(value),
    mean = mean(value)
  )
long
```
```{r}
long |> 
  pivot_wider(
    names_from = name,
    values_from = c(median, mean),
    names_vary = "slowest",
    names_glue = "{name}_{.value}"
  )
```
```{r}
df_paired <- tibble(
  a_val = rnorm(10),
  a_wts = runif(10),
  b_val = rnorm(10),
  b_wts = runif(10),
  c_val = rnorm(10),
  c_wts = runif(10),
  d_val = rnorm(10),
  d_wts = runif(10)
)
```

```{r}
df_long <- df_paired |> 
  pivot_longer(
    everything(), 
    names_to = c("group", ".value"), 
    names_sep = "_"
  )
df_long

df_long |> 
  group_by(group) |> 
  summarize(mean = weighted.mean(val, wts))
```

# Exercises pt 1 of 1
1. 
a.
```{r}
library(dplyr)
library(palmerpenguins)

penguins |> 
  summarise(across(everything(), ~ n_distinct(.)))
```
b.
```{r}
mtcars |> 
  summarise(across(everything(), mean))
```
c. 
```{r}
diamonds |> 
  group_by(cut, clarity, color) |> 
  summarise(
    n = n(),
    across(where(is.numeric), mean),
    .groups = "drop"
  )

```
2. 
```{r}
# example
mtcars |> 
  summarise(across(mpg:hp, list(mean, sd)))
```
The columns just get named "variable_1 or 2"
3. 
```{r}
expand_dates <- function(data, date_col) {
  date_col <- enquo(date_col)
  
  data |> 
    mutate(
      year  = lubridate::year(!!date_col),
      month = lubridate::month(!!date_col),
      day   = lubridate::day(!!date_col)
    ) |> 
    select(-!!date_col)
}

df <- tibble(timestamp = ymd("2020-01-01") + days(0:2))
expand_dates(df, timestamp)

```

4.
group_by(pick({{ group_vars }}))
- groups the data by the variables you pass

summarize(across(..., \(x) sum(is.na(x))))
- Computes the number of missing values in each column for each group

.groups = "drop"
- ungroups the result after the summary

select(where(\(x) any(x > 0)))
- Selects only columns where at least one group has missing values

This expression of where() only keeps columns with values that are greater than 0

# Reading Multiple Files

use dplyr::bind_rows() to combine files together
ex:

data <- bind_rows(data2019, data2020, data2021, data2022)

# Listing Files in a Directory
list.files() lists the files in a directory. 
Three arguments:

  The first argument, path, is the directory to look in.
  pattern is a regular expression used to filter the file names. The most common pattern is something like [.]xlsx$ or [.]csv$ to find all files with a specified extension.
  full.names determines whether or not the directory name should be included in the output. You almost always want this to be TRUE.
```{r}
paths <- list.files("data/gapminder", pattern = "[.]xlsx$", full.names = TRUE)
paths
```

# purrr::map() and list_rbind()

use purrr::list_rbind() to combine that list of data frames into a single data frame

# Data in the Path
```{r}
paths |> set_names(basename) 

files <- paths |> 
  set_names(basename) |> 
  map(readxl::read_excel)
```
Unable to run code without files

# Many Simple Iterations
```{r}
process_file <- function(path) {
  df <- read_csv(path)
  
  df |> 
    filter(!is.na(id)) |> 
    mutate(id = tolower(id)) |> 
    pivot_longer(jan:dec, names_to = "month")
}

paths |> 
  map(process_file) |> 
  list_rbind()
```

```{r}
paths |> 
  map(read_csv) |> 
  map(\(df) df |> filter(!is.na(id))) |> 
  map(\(df) df |> mutate(id = tolower(id))) |> 
  map(\(df) df |> pivot_longer(jan:dec, names_to = "month")) |> 
  list_rbind()
```
# Handling Failures

 possibly() takes a function and returns a function with modified behavior by changing a function from erroring to returning a value that you specify
```{r}
files <- paths |> 
  map(possibly(\(path) readxl::read_excel(path), NULL))

data <- files |> list_rbind()
```
 

```{r}
failed <- map_vec(files, is.null)
paths[failed]
```

# Writing to a Database

duckdb_read_csv():  takes a vector of paths and loads them all into the database

use DBI::dbCreateTable() to turn our template into a database table

# Writing csv Files
```{r}
by_clarity <- diamonds |> 
  group_nest(clarity)

by_clarity
```
```{r}
by_clarity$data[[1]]

by_clarity <- by_clarity |> 
  mutate(path = str_glue("diamonds-{clarity}.csv"))

by_clarity
```
```{r}
walk2(by_clarity$data, by_clarity$path, write_csv)
```

# Saving Plots
```{r}
carat_histogram <- function(df) {
  ggplot(df, aes(x = carat)) + geom_histogram(binwidth = 0.1)  
}

carat_histogram(by_clarity$data[[1]])
```

```{r}
by_clarity <- by_clarity |> 
  mutate(
    plot = map(data, carat_histogram),
    path = str_glue("clarity-{clarity}.png")
  )
```

```{r}
walk2(
  by_clarity$path,
  by_clarity$plot,
  \(path, plot) ggsave(path, plot, width = 6, height = 6)
)
```


