---
title: "Chapter 15, Regular Expressions"
format: gfm
---

```{r}
library(tidyverse)
library(babynames)
```

#Pattern Basics

str_view() will show only the elements of the string vector that match, surrounding each match with <>, and, where possible, highlighting the match in blue.
```{r}
str_view(fruit, "berry")
```

```{r}
str_view(c("a", "ab", "ae", "bd", "ea", "eab"), "a.")
```
 all the fruits that contain an “a”, followed by three letters, followed by an “e”:
```{r}
str_view(fruit, "a...e")
```

Quantifiers control how many times a pattern can match:

“?” makes a pattern optional (i.e. it matches 0 or 1 times)
“+” lets a pattern repeat (i.e. it matches at least once)
“*” lets a pattern be optional or repeat (i.e. it matches any number of times, including 0).
```{r}
# ab? matches an "a", optionally followed by a "b".
str_view(c("a", "ab", "abb"), "ab?")

# ab+ matches an "a", followed by at least one "b".
str_view(c("a", "ab", "abb"), "ab+")

# ab* matches an "a", followed by any number of "b"s.
str_view(c("a", "ab", "abb"), "ab*")
```
Character classes:
defined by [ ] 
let you match a set of characters
e.g., [abcd] matches “a”, “b”, “c”, or “d”.
invert the match by starting with ^: [^abcd] matches anything except “a”, “b”, “c”, or “d”
```{r}
str_view(words, "[aeiou]x[aeiou]")
str_view(words, "[^aeiou]y[^aeiou]")
```

alternation, |, to pick between one or more alternative patterns.

```{r}
str_view(fruit, "apple|melon|nut")
str_view(fruit, "aa|ee|ii|oo|uu")
```

# Detect Matches

str_detect() returns a logical vector that is TRUE if the pattern matches an element of the character vector and FALSE otherwise:
```{r}
str_detect(c("a", "b", "c"), "[aeiou]")
```
```{r}
babynames |> 
  filter(str_detect(name, "x")) |> 
  count(name, wt = n, sort = TRUE)
```

```{r}
babynames |> 
  group_by(year) |> 
  summarize(prop_x = mean(str_detect(name, "x"))) |> 
  ggplot(aes(x = year, y = prop_x)) + 
  geom_line()
```

# Count Matches

str_count(): tells you how many matches there are in each string.


```{r}
x <- c("apple", "banana", "pear")
str_count(x, "p")
```

```{r}
str_count("abababa", "aba")
str_view("abababa", "aba")
```

```{r}
babynames |> 
  count(name) |> 
  mutate(
    vowels = str_count(name, "[aeiou]"),
    consonants = str_count(name, "[^aeiou]")
  )
```

```{r}
babynames |> 
  count(name) |> 
  mutate(
    name = str_to_lower(name),
    vowels = str_count(name, "[aeiou]"),
    consonants = str_count(name, "[^aeiou]")
  )
```

# Replace Values

str_replace() replaces the first match
str_replace_all() replaces all matches
```{r}
x <- c("apple", "pear", "banana")
str_replace_all(x, "[aeiou]", "-")
```
str_remove() and str_remove_all() are handy shortcuts for str_replace(x, pattern, ““):
```{r}
x <- c("apple", "pear", "banana")
str_remove_all(x, "[aeiou]")
```

# Extract Variables

```{r}
df <- tribble(
  ~str,
  "<Sheryl>-F_34",
  "<Kisha>-F_45", 
  "<Brandon>-N_33",
  "<Sharon>-F_38", 
  "<Penny>-F_58",
  "<Justin>-M_41", 
  "<Patricia>-F_84", 
)
```

```{r}
df |> 
  separate_wider_regex(
    str,
    patterns = c(
      "<", 
      name = "[A-Za-z]+", 
      ">-", 
      gender = ".",
      "_",
      age = "[0-9]+"
    )
  )
```

# Exercises pt 1 of 2
1. 
```{r}
babynames |> 
  count(name) |> 
  mutate(
    vowels = str_count(name, "[aeiouAEIOU]")) |>
  filter(vowels == max(vowels))
  
```
```{r}
babynames |> 
  count(name) |> 
  mutate(
    vowels = str_count(name, "[aeiouAEIOU]"),
    total_letters = nchar(name),
    vowel_prop = vowels / total_letters
  ) |> 
  filter(vowel_prop == max(vowel_prop))
  
```

2. 
```{r}
str_replace_all("a/b/c/d/e", "/", "\\\\")
```
3. 
```{r}
library(stringr)

str_replace_all("Hello WORLD!", setNames(letters, LETTERS))

```
4.
```{r}
tibble(str = "123-456-7890") |>
  separate_wider_regex(
    str,
    patterns = c(
      area = "\\d{3}",
      "-", 
      central = "\\d{3}",
      "-", 
      station = "\\d{4}"
    )
  )
```

# Escaping

```{r}
# To create the regular expression \., we need to use \\.
dot <- "\\."

# But the expression itself only contains one \
str_view(dot)

# And this tells R to look for an explicit .
str_view(c("abc", "a.c", "bef"), "a\\.c")
```

```{r}
x <- "a\\b"
str_view(x)
str_view(x, "\\\\")
```

```{r}
str_view(x, r"{\\}")
```

```{r}
str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")
str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")
```
# Anchors

To force a regular expression to match only the full string, anchor it with both ^ (beginning) and $ (end):
```{r}
str_view(fruit, "^a")
str_view(fruit, "a$")
```
```{r}
str_view(fruit, "apple")
str_view(fruit, "^apple$")
```

```{r}
x <- c("summary(x)", "summarize(df)", "rowsum(x)", "sum(x)")
str_view(x, "sum")
str_view(x, "\\bsum\\b")
```

```{r}
str_view("abc", c("$", "^", "\\b"))
str_replace_all("abc", c("$", "^", "\\b"), "--")
```

# Grouping and Capturing

```{r}
str_view(fruit, "(..)\\1")
```
All words that start and end with the same first two letters:
```{r}
str_view(words, "^(..).*\\1$")
```
```{r}
sentences |> 
  str_replace("(\\w+) (\\w+) (\\w+)", "\\1 \\3 \\2") |> 
  str_view()
```
# Exercises pt 2 of 2
1. 
```{r}
pattern1 <- "’\\? How about"
pattern2 <- "“\\$\\^\\$“"

pattern1
pattern2
```
2. The only pattern that matches a : is ":" which is not created by these patterns
3. 
```{r}
library(stringr)
words <- stringr::words
str_subset(words, "^y")
```
```{r}
str_subset(words, "^[^y]")
```
```{r}
str_subset(words, "x$")
```
```{r}
str_subset(words, "^(...)$")
```
```{r}
str_subset(words, "^.{7,}$")
```
```{r}
str_subset(words, "[aeious][^aeiou\\W]")
```
```{r}
str_subset(words, "([aeiou][^aeiou\\W]){2,}")

```
```{r}
str_subset(words, "^([aeiou][^aeiou\\W])+$")

```

4.
a[ei]roplane, alumin(i)?um, analogu?e, a(rs)?se?, cent(re)?, defen[cs]e, dough?nuts?, gr[ae]y, modell?ing, scept?ic, summari[sz]e

5.
```{r}
str_subset(words, paste0("^", str_sub(words, -1, -1), ".*", str_sub(words, 1, 1), "$"))
```
6.
^.*$ (start of string, any number of characters, end of string)
“\.+\” (backslash, followed by one or more characters, backslash)
-- (matches two hyphens)
“\{4}” (A literal { followed by the digit 4)
...... (six characters)
(.)\1\1 (three identical characters)
“(..)\1” (two characters repeated)
